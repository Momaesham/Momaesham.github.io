# Аргументы функций

Рассмотрим пример

```python
def my_fn(a,b):
    a = a + 1
    c = a + b
    return c

my_fn(10, 3)
```

a и b являются `параметрами функции`

10 и 3 являются `аргументами функции`

Наша функция `my_fn` может вызывать большое количество раз и изменяться будут лишь `аргументы`. Сейчас мы имеет 2 позиционных аргумента, это означает, что первый аргумент (10) будет передан в первый параметр функции (a), а второй аргумент (3) во второй (b). Если мы переставим местами аргументы при вызове функции, то значения в функции будут наоборот: a = 3, b = 10.

## Ошибка отсутствия аргументов

```python
def sum_nums(a, b):
    c = a + b
    return (c)

print(sum_nums(2,5)) # 7

print(sum_nums(2))
# TypeError: sum_nums() missing 1 required positional argument: 'b'

print(sum_nums())
# TypeError: sum_nums() missing 2 required positional arguments: 'a' and 'b'
```

## Ошибка большего количество аргументов

```python
def sum_nums(a, b):
    c = a + b
    return (c)

print(sum_nums(2,5,7))
# TypeError: sum_nums() takes 2 positional arguments but 3 were given
```

Можем сделать вывод, что используя позиционные аргументы мы должны передавать ровно нужное количество аргументов

А если мы не знаем, сколько аргументов нам придёт в функцию? В python есть возможность работы с такими ситуациями

## Объединение аргументов в tuple

```python
def sum_nums(*args):
    print(args) # 2, 3, 7
    print(type(args)) # <class 'tuple'>

    print(args[0]) # 2
    return sum(args)

print(sum_nums(2, 3, 7)) # 12
```

В параметрах у нас указан лишь один параметр `*args`. С помощью знака * и происходит объединение всех аргументов в один кортеж. 

При вызове функции указаны три позиционных аргумента, для них порядок следования важен. 

## Аргументы с ключевыми словами

До этого мы работали с позиционными аргументами, а сейчас разберём аргументы с ключевыми словами. `Это означает, что при вызове функции мы передаём не только значение, но и имя параметра, который должен это значение принять. При такой записи, нам не важен порядок следования аргументов в вызове функции.`

Такая запись позволяет сделать код более читаемым, а также, порядок следования аргументов становится не важен.

```python
def get_user_info(name, age):
    info = 'User:', name, 'age:', age
    return info

info = get_user_info(age = '32', name = 'Bob')
print(info)
# ('User:', 'Bob', 'age:', '32')
```

Допускается использование позиционных аргументов вместе с ключевыми словами

```python
def get_user_info(name, age):
    info = 'User:', name, 'age:', age
    return info

info = get_user_info('Bob', age = '32')
print(info)
# ('User:', 'Bob', 'age:', '32')
```

## Объединение аргументов в dict

С помощью `двух звёздочек` мы преобразовываем все именованные аргументы в словарь, внутри функции. 

Также можем передавать сколь угодно много аргументов в функцию.

Перепишем предыдущий пример

```python
def get_user_info(**user):
    print(user)
    # {'name': 'Bob', 'age': '32'}
    info = 'User:', user['name'], 'age:', user['age']
    return info

info = get_user_info(name = 'Bob', age = '32')
print(info)
# ('User:', 'Bob', 'age:', '32')
```

Сейчас в параметрах функции указан один параметр (**user), который принимает все аргументы с ключевыми словами и формирует в словарь.


# Значение параметров функции по умолчанию

В python есть возможность задать значение при отсутствии переданного аргумента каким-то шаблоном, который мы напишем. 

В примере, для параметра `multiplier` задано значение по умолчанию, оно равно 1. Значит, если был передан лишь один аргумент, то на место `multiplier` ставится значение 1.

```python
def mult_by_factor(value, multiplier = 1):
    return value * multiplier

print(mult_by_factor(10, 2)) # 20
print(mult_by_factor(5)) # 5
```

