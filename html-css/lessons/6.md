# Селекторы

- Селекторы по ID
- Селекторы по классу
- Селектор по типу
- Селектор потомков
- Список селекторов
- Универсальные селекторы
- Селектор дочерних элементов
- Смежные селекторы
- Селектор следующего элемента

---

# Селекторы по ID

В HTML-документах CSS-селекторы по `ID` производят выборку всех элементов по `ID`, полностью совпадающих с селектором.

### Синтаксис

```css
#id_value {
    style: properties;
}
```

### Пример

```css
span#identified {
  background-color: DodgerBlue;
}

```

---

# Селектор по типу

CSS селекторы по типу выбирают элементы по имени узла. Используются отдельно, поэтому, селектор типа для конкретного имени тега выбирает все элементы этого типа, то есть с этим именем узла в документе.

### Синтаксис

```css
element {
  style: properties;
}
```

### Пример

```css
span {
  background-color: DodgerBlue;
  color: #ffffff;
}
```

---

# Селекторы по классу

В HTML документе, селекторы по CSS классу находят элементы с нужным классом. Атрибут класса определяется как разделённый пробелами список элементов, и один из этих пунктов должен точно соответствовать имени класса, приведённому в селекторе.

### Синтаксис

```css
.classname {
  style: properties;
}
```

### Пример

```css
span.classy {
  background-color: DodgerBlue;
}
```

---

# Селектор потомков

Комбинатор `␣` (пробел) представляет собой 2 или более селекторов, найдёт элементы соответствующие обоим селекторам. Селекторы по потомкам похожи на селекторы дочерних элементов, но они не учитывают вложенность элементов и применяют свои свойства ко всем элементам данного типа, находящимся внутри родительского элемента, независимо от глубины вложенности.

### Синтаксис

```css
selector1 selector2 {
    style: properties;
}
```

### Пример

```css
div span { 
    background-color: DodgerBlue;
}
```

---

#  Список селекторов

CSS список селекторов `,` выбирает все соответствующие элементы.

### Синтаксис

```css
element, element, element {
  style: properties;
}
```

### Пример

```css
h1, h2, h3, h4, h5, h6 { font-family: helvetica; }
```

---

# Универсальные селекторы

Звёздочка `*` - универсальный селектор для CSS. Соответствует любому тегу

### Синтаксис

```css
* {
  style: properties;
}
```

### Пример

```css
*[lang^=en]{color:green;}
*.warning {color:red;}
*#maincontent {border: 1px solid blue;}
```

---

# Селектор дочерних элементов

Комбинатор `>` разделяет 2 селектора, находит элементы заданные вторым селектором, являющие прямыми потомками для элементов отобранных первым селектором. Напротив, два селектора в селекторе потомков  находят элементы не обязательно являющиеся прямыми потомками, т.е. несмотря на количество "прыжков" до них в DOM.

### Синтаксис

```css
selector1 > selector2 {
  style: properties;
}
```

### Пример

```css
span { background-color: white; }
div > span {
  background-color: DodgerBlue;
}
```

---

# Смежные селекторы

Указывает на смежный или следующий селектор. Обеспечивает выбор только элемента расположенного непосредственно за определённым в первой части элементом.

### Синтаксис

```css
former_element + target_element { style: properties; }
```

### Пример

```css
li + li {
  color: red;
}
```

---

# Селектор следующего элемента

Общий комбинатор смежных селекторов `~` разделяет два селектора и находит второй элемент только если ему предшествует первый, и они оба имеют общего родителя. Свойства будут применены ко всем элементам, указанным в правой части, следующим за элементом, указанным в левой части.

### Синтаксис

```css
element ~ element { style properties } }
```

### Пример

```css
p ~ span {
  color: red;
}
```

---

# `float`

Элемент, для которого указано это свойство, частично выходит из потока: все элементы блочного контекста, прописанные в коде после элемента с `float`, занимают его место, а элементы строчного контекста — «обтекают» его.

Три значения свойства:

- `left` — элемент встанет у левого края родительского блока.
- `right` — элемент встанет у правого края родительского блока.
- `none` — значение по умолчанию, элемент останется в потоке.

```css
.element {
  float: left;
}
```

> Применяя `float` к элементу, мы неявно делаем его блочным.

Для отмены обтекания исползуется свойство `clear`

```css
.clearfix {
  clear: both;
}
```

---

# `position`

Позиционирование позволяет вам изымать элементы из нормального потока макета документа и заставить их вести себя по-другому; например, располагаться друг на друге или всегда оставаться на одном и том же месте внутри окна просмотра браузера

Значения:
- static
- relative
- top, bottom, left, и right
- absolute
- fixed
- sticky 
- z-index

---

# `position:static`

Любой элемент, добавленный на страницу, будет иметь это значение и будет расположен в нормальном потоке документа согласно контексту форматирования родительского элемента

```css
.positioned {
  position: static;
  background: yellow;
}
```

---

# `position:relative`

Элемент позиционируется так же, как и статичный, но его отображение может быть смещено относительно своего начального положения при помощи свойств `left`, `right`, `top`, `bottom`

> Это смещение чисто визуальное и не затрагивает положение соседних элементов, кроме случая, когда элемент выходит за границы родителя, имеющего возможность прокрутки

```css
div {
    position: relative;
}
```

---

# `top`, `bottom`, `left`, и `right`

`top`, `bottom`, `left` , и `right` используются вместе с `position` чтобы указать куда именно перемещать позиционируемый элемент.

```css
div{
    position: relative;
    top: 30px;
    left: 30px;
}
```

---

# `position:absolute`

Задаёт абсолютное позиционирование и при помощи свойств `left`, `right`, `top`, `bottom` регулирует положение элемента

Есть ряд особенностей такого позиционирования:

- Элемент убирается из основного потока документа. То есть, перестаёт влиять на положение окружающих элементов и на размер родителя. Можно представить себе, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме своих потомков.
- Элемент позиционируется относительно ближайшего позиционированного предка. То есть, браузер идёт вверх по дереву элементов и ищет ближайшего опорного родителя. И затем располагает наш элемент относительно этого родителя.
- Если элемент был частью строчного контекста форматирования, он приобретает блочный контекст форматирования. К нему становится применима блочная модель.
- Если элемент был блочным и занимал всю ширину своего родителя, то теперь его ширина будет определяться шириной контента.
- Отступы элемента с `position: absolute` не схлопываются с отступами соседних элементов.

```css
div{
    position: absolute;
}
```

---

# `position:fixed`

Позиционирует  элемент не относительно родителя, а относительно окна браузера вне зависимости от вложенности

```css
div{
    position: fixed;
}
```
У такого способа позиционирования есть ряд особенностей:

- Элемент убирается из основного потока документа. То есть, перестаёт влиять на положение окружающих элементов и на размер родителя. Можно представить себе, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме своих потомков.
- Элемент позиционируется относительно окна браузера


---

# `position:sticky`

Элемент с `position: sticky` «прилипает» к экрану при прокрутке, пока не встретится с границей родительского блока.

```css
.block {
  position: sticky;
  top: 15px;
}
```

> Для блока, который должен быть «липко» позиционирован, указываем `position: sticky` и позицию относительно окна браузера.

---

# `z-index`

Обычно элементы на странице располагаются только в двух измерениях — `x` (горизонталь) и `y` (вертикаль). Но в отдельных случаях, когда позиционирование элементов отличается от статичного, появляется третье измерение `z`, отвечающее за глубину.

Свойство `z-index` позволяет управлять порядком наложения элементов друг на друга.

```css
.selector {
  z-index: auto;
  z-index: 0;
  z-index: -1;
  z-index: 1;
  z-index: 9999999;
  z-index: -999999;
}

```

---

# `overflow`

Свойство `overflow` позволяет буквально определить, что делать с содержимым блочного (то есть для элемента, у которого `display` определяется как `block`, `inline-block`, `flex` или `grid`) элемента, если оно не влезает в размеры — отобразить или обрезать (с полосами прокрутки или без).

Значения:
- `visible` — содержимое отображается снаружи родительского блока, если его размеры больше размеров «родительского» блока (значение по умолчанию);
- `hidden` — содержимое, выходящее за пределы «родительского» блока, обрезается по его границам без прокрутки;
- `clip` — новое значение (поддерживается всеми основными браузерами, кроме Safari), похожее по результату на hidden, но границы родительского блока рассчитываются с учётом внутренних отступов;
- `scroll` — контент обрезается по границам «родительского» блока, но внутри этой области содержимое доступно с помощью прокрутки;
- `auto` — если содержимое переполняет блок, контент будет доступен для прокрутки.

---
# `box-shadow`

Свойство, бросающее тень на ваши блоки. Создано, чтобы имитировать объекты реального мира и создавать иллюзию объёма для плоских элементов интерфейса.

Пример:
Частая ситуация — выделить кнопку, задав ей тень, что визуально сделает её объёмной.
``` html
<button class="button">Купить немедленно!</button>
```

Помимо основных оформительских стилей задаём нашей кнопке тень:
``` css
.button {
  box-shadow: -15px 15px 0 0 #ED6742;
}
```
