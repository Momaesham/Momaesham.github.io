# Game Library

## Занятие 3. Логика приложения, изменение данных и фильтрация

### Цель занятия
На этом занятии мы:

* научимся **изменять данные**, а не только добавлять их
* разберём работу с массивами объектов
* реализуем смену статуса игры
* добавим фильтрацию списка
* закрепим архитектуру: где должна жить логика

После этого занятия приложение начинает вести себя как полноценный продукт.

---

## Почему логика — самая важная часть приложения

Интерфейс — это только оболочка.

Настоящая ценность приложения — в логике:

* как изменяются данные
* какие данные показываются пользователю
* как приложение реагирует на действия

На этом занятии мы работаем именно с этим уровнем.

---

## Повтор: структура данных

Каждая игра — объект.

Пример:

```js
{
  id: 1,
  title: 'Cyberpunk 2077',
  genre: 'RPG',
  status: 'playing'
}
```

Все игры хранятся в массиве:

```js
const [games, setGames] = useState([])
```

Мы будем **изменять элементы этого массива**.

---

## Основные методы массивов

В этом занятии мы используем три ключевых метода:

### map
Используется, когда нужно:

* пройтись по массиву
* изменить каждый элемент
* вернуть новый массив

---

### filter
Используется, когда нужно:

* убрать часть элементов
* оставить только подходящие

---

### find
Используется, когда нужно:

* найти один конкретный элемент

---

## Иммутабельность данных

React не отслеживает изменения внутри массива.
Он отслеживает **замену ссылки**.

Это значит:

* нельзя менять объект напрямую
* всегда создаём новый массив и новые объекты

---

## Изменение статуса игры

Задача:

* пользователь нажимает кнопку
* у игры меняется статус
* интерфейс обновляется

Алгоритм:

1. получить `id` игры
2. пройтись по массиву `games`
3. найти нужную игру
4. вернуть новую версию объекта
5. сохранить новый массив в state

---

## Где должна жить логика изменения

Важно:

* `GameItem` **не должен** менять данные
* логика изменения должна быть в `App`

`GameItem`:

* отображает данные
* сообщает о событии (клик, выбор)

`App`:

* принимает событие
* меняет state

---

## Передача обработчиков через props

Пример:

```js
<GameItem game={game} onStatusChange={changeStatus} />
```

Компонент не знает, **как** меняются данные.
Он просто вызывает функцию.

---

## Статусы игры

Вводим фиксированные статусы:

* `planned` — хочу пройти
* `playing` — прохожу
* `completed` — пройдено

Это позволит:

* фильтровать игры
* менять внешний вид

---

## Фильтрация списка игр

Фильтрация — это:

* отображение части данных
* без изменения исходного массива

Мы создаём:

* отдельное состояние `filter`
* вычисляемый список игр

---

## Где должна происходить фильтрация

Фильтрация:

* не меняет данные
* влияет только на отображение

Значит:

* данные (`games`) остаются как есть
* отображаемый список вычисляется перед рендером

---

## Практика

### Шаг 1. Кнопка смены статуса

* Добавить кнопку в `GameItem`
* Передать `id` игры при клике

---

### Шаг 2. Функция changeStatus в App

* Реализовать изменение статуса через `map`
* Обновлять state через `setGames`

---

### Шаг 3. Визуальное различие статусов

* Разные цвета или подписи
* Использовать условный рендеринг

---

### Шаг 4. Состояние фильтра

* Создать `useState` для фильтра
* Возможные значения: all / planned / playing / completed

---

### Шаг 5. Фильтрация списка

* Использовать `filter`
* Отображать только нужные игры

---

## Типичные ошибки

* менять объект игры напрямую
* хранить фильтр в `GameList`
* фильтровать исходный массив и терять данные
* писать логику внутри `GameItem`

---

## Итог занятия

После третьего занятия:

* уверенно работаем с массивами объектов
* понимаем разницу между данными и отображением
* реализуем изменение состояния
* используем `map` и `filter` осознанно
* пишем более чистую архитектуру

На следующем занятии:

* побочные эффекты
* `useEffect`
* сохранение данных в `localStorage`
